<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="chap:intro">
  <?dbhtml filename="how-did-we-get-here.html"?>
  <title>我们是怎么到这一步的？</title>

  <sect1>
    <title>为什么需要版本控制？为什么选择Mercurial？</title>

    <para id="x_6d">版本控制是管理一段信息多个版本的操作。它最简单的形式，
      是很多人都亲手做过的事：每当你改了一个文件，另存为一个原文件名后加上一
      个数字的新文件，每次都递增这个数字。</para>

    <para id="x_6e">手动管理多个版本，即使只是针对单个文件，也是件很容易犯错的事
      情。所以，很早就有相应的软件工具来帮助自动化这个操作。最早的自动化版本
      控制工具是用来为单个用户管理单个文件的版本的。经过了几十年，版本控
      制工具的能力范围已经得到了极大的扩展。现在它们能管理多个文件，并且能帮助多
      个用户协同工作。最好的现代版本控制工具可以轻松胜任成千上万的人一起协同
      工作。</para>

    <para id="x_6f">分布式版本控制则是最近的事。到现在为止，由于人们也很乐意在这片未知领域里冒险，这个领域得到
      了很大发展。</para>

    <para id="x_70">我相信给这些人一份引导图是很重要的事，所以我开始写作这样
      一本关于分布式版本控制的书。我之所以选择Mercurial是因为这是用来了解这
      一地带最简单的工具，而且它也能满足真实的，极具挑战性的环境下的需求，很
      多其他的版本控制工具可没这样的能耐。</para>

    <sect2>
      <title>为什么使用版本控制</title>

      <para id="x_71">为什么你或者你的队伍应该想要在项目使用自动化的
        版本控制工具，那可有一堆的理由。</para>

      <itemizedlist>
        <listitem><para id="x_72">它能追踪你项目的历史和演变，所以你可以不再
            管这些杂事。对于每一个改动，你都会得到一条Log，其中记录了：<emphasis>谁
            </emphasis>改动的；<emphasis>为什么</emphasis>要改动它；<emphasis>
            什么时候</emphasis>改动的；以及<emphasis>哪些东西</emphasis>被改动了。
      </para></listitem>
      <listitem><para id="x_73">当你和其他人一起工作时，版本控制软件可以让
          你们更轻松的共事。比方说，当有人或多或少同时做了潜在的不兼容的改
          动时，软件会帮助你指出并解决这些冲突。</para></listitem>
      <listitem><para id="x_74">它能帮你从错误中恢复过来。如果你做了一个之
          后被证明是错误的改动时，你可以将一个或多个文件回退至更早版本。
          事实上，一个<emphasis>真正</emphasis>好的版本控制工具甚至可以帮你
          发现是什么时候引入这个问题的。(更多信息请参见
          <xref linkend="sec:undo:bisect"/> ).</para></listitem>
      <listitem><para id="x_75">它能帮你在一个项目的多个版本中自由来去。{?}
    </para></listitem></itemizedlist>

    <para id="x_76">这些理由中的绝大多数都同等重要&emdash;至少在理论上&emdash;，
      无论你是独立做一个项目，还是跟一百个人。</para>

    <para id="x_77">在两个不同重量级（<quote>独行
        侠</quote>和<quote>大型团队</quote>）上施行版本控制，有一个关键问题：
      它的<emphasis>收益</emphasis>和它的<emphasis>开销</emphasis>相比如何。
      一个版本工具如果很难理解或者使用，就代表它的开销很大。</para>

    <para id="x_78">一个拥有500人的项目要是不用版本控制工具和方法，它几乎会马
      上被自身的规模压垮。这时，使用版本控制几乎不会被认为是一种开销，因为
      <emphasis>没有</emphasis>它，失败在所难免。</para>

    <para id="x_79">另一方面，对于单人的一次小打小闹，版本控制工具又显得有点
      儿尴尬，因为它几乎肯定占了整个项目的绝大多数开销，不是吗？</para>

    <para id="x_7a">Mercurial为<emphasis>两种</emphasis>不同重量级的项目都提
      供了独一无二的支持。你可以仅仅花上几分钟就能学会Mercurial的基本操作，凭借
      其极低的开销，你可以在极小的项目种也轻松用上版本控制。它的简易性使得你
      不需要有深奥的概念或者各种神奇的命令序列，那些玩意儿真心搞脑子（译者注：
      好吧，明显是在影射我们的git殿下）。相同的时间里，Mercurial凭着它的高性
      能和点对点的天性让你轻松应对各种大型项目了。</para>

    <para id="x_7b">没有任何一个版本控制工具可以拯救一个糟糕的项目，但
      是，一次明智的选择可以对一个项目的顺畅度产生重大的改观。</para>

  </sect2>

  <sect2>
    <title>版本控制的名字们</title>

    <para id="x_7c">版本控制是一个五花八门的领域，多到连名字和简写都有一大
      堆。这些列举了一些你可能会遇到的常见的形式。</para>
    <itemizedlist>
      <listitem><para id="x_7d">版本控制 Revision control (RCS)</para></listitem>
      <listitem><para id="x_7e">软件配置管理 Software configuration management
          (SCM)，或者配置管理 configuration management</para></listitem>
      <listitem><para id="x_7f">源代码管理 Source code management</para></listitem>
      <listitem><para id="x_80">源代码控制 Source code control或者代码控制 source
          control</para></listitem>
      <listitem><para id="x_81">版本控制 Version control
          (VCS)</para></listitem></itemizedlist>
    <para id="x_82">有的人声称这些术语其实有不同的含义，但是事实上它们含义都雷
      同到没有什么方法可以将它们区别开来了。</para>

  </sect2>
</sect1>

<sect1>
  <title>关于书中的样例</title>

  <para id="x_84">本书使用了不同一般的方式来展现代码样例。每个例子实际都是
    <quote>活的</quote>&emdash;它们实际都是一个Shell脚本执行了Mercurial
    命令后的结果。每一次编译都会自动执行所有的样例，比较实际结果和预期结果，
    并且生成新的图像。</para>

  <para id="x_85">这种方式的好处在于例子永远都是<emphasis>精确无误的</emphasis>。
    它精准描述了书中提到的版本执行该命令的行为。如果我更新了书中Mercurial
    的版本，造成了一些命令的输出有所改变，那么编译就会失败。</para>

  <para id="x_86">这样做也有不好的地方，你会看到样例中所有的日期和时间都非
    常接近，显然不可能是人类执行这些命令会产生的结果。人们输入命令和命令之
    间，总会有数秒的延迟，而我这个脚本的结果就是很多命令都是同一秒中被执行
    的。</para>

  <para id="x_87">举个例子，一个例子中多次连续的提交就会显示是在同一秒中发
    生的，你可以看这个章节<literal role="hg-ext">bisect</literal>中的样例
    <xref linkend="sec:undo:bisect"/></para>

  <para id="x_88">所以，在你阅读这些样例的时候，请不要过于在意这些结果的时
    间，你应该清楚知道这些行为的结果是一致的，而且是可以再现的。</para>

</sect1>

<sect1>
  <title>本领域的发展趋势</title>

  <para id="x_89">在过去四十多年里，版本控制工具的开发和使用上已经有一个非
    常清晰的趋势，那就是人们越来越清楚他们的工具的能力以及它们的不足。</para>

  <para id="x_8a">第一代工具开始管理单台电脑上的单个文件。虽然这些工具已经
    表现出了相比各自为战的手工版本控制巨大的优势，但是他们的锁定模式和受限
    于单台电脑的特性还是对他们的能力产生了巨大的束缚，只能用在极小规模的开
    发队伍中。</para>

  <para id="x_8b">第二代工具通过向网络为中心的架构发展，松绑了这些约束， 于
    是它们可以用来一次控制整个项目了。不过，当项目持续增长，它们又碰到了新
    问题。由于客户端需要与服务器进行频繁的交互，服务器的增长成了大项目时的
    一个问题。而一个不可靠的网络连接，甚至可以完全让客户端无法与服务器进行
    交互。而且，开源项目开始向大家开放匿名访问的只读访问权限时，人们发现他
    们根本无法正常使用这些工具，因为他们根本没有提交的权限，所以无法记录他
    们的变更。</para>

  <para id="x_8c">而当代的版本控制工具天生就是点对点的。所有的这些工具都不
    在依赖于单点的中心服务器，而允许人们在需要的地方发布他们的版本控制数据。
    同时，由于技术的发展，因特网间的合作已经变作可能并且被大家广为接受了。
    现代工具可以离线进行不受限自主操作，网络连接仅仅在与其他仓库同步变更时
    才需要。</para>

</sect1>
<sect1>
  <title>分布式版本控制的优点</title>

  <para id="x_8d">尽管分布式版本控制工具好多年前就已经像它们的前辈那样可用
    和可靠了，人们还是热衷于使用老一代的工具，这造成了它们至今没有大放光彩。
    与中心化工具相比，分布式版本控制有以下几方面的优点。</para>

  <para id="x_8e">对于开发者个人而言，分布式工具几乎总意味着远远的快过集中
    式的工具。理由很简单：中心化工具绝大多数操作都必须经过网络，因为它们
    的很多元数据都只在中央服务器上保存单份。而分布式工具在本地保存了所有的
    元数据。其实其他也没有什么太大的不同，毕竟通过网络是一项大开销的事。别
    低估了敏捷、快速响应工具的价值，要知道，你可是要花很多时间与你的版本控
    值软件打交道的。</para>

  <para id="x_8f">分布式工具对你服务器可能会遇到的各种不测根本漠不关心，同
    样是因为它们把元数据保存在很多地方。当你的中央服务器突然着火了，你最好
    祷告你的备份媒体是坚不可摧的，否则你最多恢复到最近一次的成果。而分布式
    工具则可以从每个开发者的电脑上找回完整的备份。</para>

  <para id="x_90">网络的可靠度对分布式工具的影响远远低于中心化工具。你甚
    至无法离开网络，如果你是在用中心化工具，除非是一些很少量的命令。而如果
    是在用一个分布式工具，你可能在网络已经断开后也根本意识不到。因为你只有
    要和其他电脑上的仓库进行交互时，你才会需要网络，而比起你用本地命令来，
    那真是要少得多。如果你是一个偏远团队的合作者，那对你而言这真是意义重大。
  </para>

  <sect2>
    <title>对开源项目的优势</title>

    <para id="x_91">如果你受益于一个开源项目，并且开始考虑加强它，而碰巧那
      个项目采用了分布式版本控制工具，你就可以马上与那些被认为是项目核心的
      大人物们一同参与了。如果他们发布了他们的仓库，你可以马上复制他们所有
      的项目历史，开始修改代码，并记录你的工作，就像那些大人物一样用着一样
      工具，用着一样的方式。相反，如果是中心化工具，除非他们给你权限，不然
      你就只能以只读方式来使用版本控制工具。你将无法记录你的变更，而且每次
      你试着更新时都要冒着本地代码被破坏的风险。</para>

    <sect3>
      <title>简易的创建分支</title>

      <para id="x_92">分布式版本控制工具总让人怀疑会给开源项目造成某种伤害，
        因为它非常容易创建一个项目开发分支。当在项目内部发生了观点或者态度
        发生了激烈冲突后，很可能就会重新创建一个分支（因为这太容易了）各分
        东西，造成项目的崩分离析。</para>

      <para id="x_93">有时不同阵营希望能够重归于好。用一个中心化版本控制工
        具的话，<emphasis>技术上</emphasis>合二为一就是一个痛苦的过程，而且
        必须进行大量的手工操作。你必须决定到底应该使用哪个版本历史，然后把
        其他团队的变更移植进来，而整个过程通常要丢失另一边一些，甚至是全部
        的版本历史。</para>

      <para id="x_94">而对于分布式工具，创建分支是开发项目<emphasis>唯一的
        </emphasis>的方式。你所做的任何单次变更都被认为是一个潜在的分支点。
        这种方式的优势在于这使得一个分布式版本控制工具不得不特别擅长<emphasis>
          合并</emphasis>分支这项操作，因为他们每次都在合并。</para>

      <para id="x_95">如果每个人在任何时候所做的任何工作，都可以纳入分支、
        合并的范畴，那么开源世界所谓的<quote>分支</quote>就<emphasis>纯粹
        </emphasis>是一个社区化的事件。真要说起来的话，分布式工具<emphasis>
        减弱</emphasis>了分支的可能性：</para>
      <itemizedlist>
        <listitem><para id="x_96">它们消除了中心化工具所带来的社区地位的分
            别：所谓的圈内人（有提交权限）和圈外人（没有提交权限）间的区别。
        </para></listitem>
        <listitem><para id="x_97">它们使得社区进行分支后的归一变得更简单，
            因为从版本控制系统软件的角度来看，所牵涉到的一切不过是又一次合
            并。</para></listitem></itemizedlist>

      <para id="x_98">有些人因为想要对他们的项目进行严格的控制所以抵制使用
        分布式工具，他们相信中心化工具给了他们这个控制手段。但是，如果你是
        信徒的其中之一，而且你公开发布了你的CVS或者Subversion仓库，还是有
        不少工具可以把你整个项目的历史下载下来（当然这很耗时）并且在你控制
        之外再创建一个。所以，在这种情况下，你所谓的控制就是一件虚无缥缈的
        事情了。你还是放弃这种想法，索性让人们无论如何都得创建分支并镜像你
        所有的历史吧，这样可以让你更顺畅的与其他人一起协作。</para>

    </sect3>
  </sect2>
  <sect2>
    <title>对商业项目的优势</title>

    <para id="x_99">很多商业项目都是由遍布全球的各个团队进行维护的。那些远
      离中心服务器的工作人员的操作会非常慢，而且常常会发生连接不稳定的情况。
      商业版本控制系统视图靠在远程放置一些附加的镜像服务器来解决这个问题。
      显然，这不但会增加开销，而且会增加你和坏脾气的管理员照面的机会。分布
      式系统就可以从一开始就让你远离这些麻烦。而且，你可以简单的设置多个需
      认证的服务器，假设每个工作地一台，这样就可以避免冗余的仓库间通信，那
      可是非常耗时而且昂贵的。</para>

    <para id="x_9a">中心化版本控制系统不可避免会造成更低的可伸展性。如果只
      有少于12人的队伍，一般不会选用一款昂贵的中心化系统来开始工作。而且，
      如果你就只有一台服务器，一次标准的响应往往是会造成因为大量复制而产生
      很大开销，那会比分布式工具慢上好几倍（因为所有的数据已经复制到各处了
      ），单个廉价的服务器就完全可以掌握更大的团队，而且如果你想复制数据来
      平衡负载的话也只需做一些脚本工作就行了。</para>

    <para id="x_9b">假设你有这么一个员工，他正在查找客户网站上的一个问题，
      他们将会从分布式版本控制中受益良多。因为这使得为各个客户单独的生成
      一个版本成了可能，他可以尝试各种不同的修正方法而不会影响到别人，而
      且即使在客户那里也能方便快速的查找代码和Bug修正的历史信息，所有的一
      切都不需要访问你公司的网站。</para>
  </sect2>
</sect1>
<sect1>
  <title>为什么选用Mercurial？</title>

  <para id="x_9c">Mercurial有着以下独特的特性，这使得它成为了你选择版本控
    制系统时的一个绝佳选择。</para>
  <itemizedlist>
    <listitem><para id="x_9d">易学易用。</para></listitem>
    <listitem><para id="x_9e">轻量。</para></listitem>
    <listitem><para id="x_9f">极佳的伸缩性。</para></listitem>
    <listitem><para id="x_a0">定制容易。</para></listitem></itemizedlist>

  <para id="x_a1">只要你熟知版本控制系统，你就能在5分钟内掌握并开始使用它。
    就算你不熟悉，那也多花不了你几分钟。Mercurial的命令和特性非常统一和一致，
    所以你不用记住那些个“例外”，只要掌握一些基本法则就可以掌握它。</para>

  <para id="x_a2">对于一个小项目，你可以立刻开始使用Mercurial。对代码做一些
    变更， 建一些分支，然后传递这些变更（在本地或者跨网络），查看历史和状态
    这些操作都非常快。Mercurial试图确保其敏捷性，并通过可见但很低的额外开销
    和超快的操作的结合，不干扰用户。</para>

  <para id="x_a3">当然，Mercurial的实用性并非仅仅局限在小型项目中。现在使用
    它的项目有着上百甚至上千的提交者，上万的文件数，成百兆的源代码。</para>

  <para id="x_a4">如果你觉得Mercurial的核心功能还不足以满意你的需求，添加功
    能也很容易。Mercurial很适合处理脚本任务。它的内部结构清晰，并以Python实
    现，因此很容易使用扩展（Extension）来增加特性。现在已经有很多流行而且有
    用的扩展了，有的可以帮助你指出错误，也有提升性能的。</para>

</sect1>
<sect1>
  <title>Mercurial相比其他工具</title>

  <para id="x_a5">在你阅读本节之前，你先要知道，这节的内容仅仅是根据我个人
    的经验，兴趣和偏见（请允许我这么说……）而言的。不过我确实实际使用过下面
    所列的所有版本控制工具，大多数场合下，我都一次使用过多年。</para>


  <sect2>
    <title>Subversion</title>

    <para id="x_a6">Subversion是流行的版本控制工具，当初是为了替代CVS而开发
      的。它采用了中心化的客户端/服务端框架。</para>

    <para
      id="x_a7">Subversion和Mercurial有着相似的命令来完成一个操作，所以你如
      果熟悉其中一个，就会很容易掌握另一个。两个工具都支持主流的操作系统。</para>

    <para id="x_a8">在1.5版之前，Subversion对合并没什么给力的支持。在写本书
      时，它有了新的合并跟踪能力，但是还是一样的 <ulink
        url="http://svnbook.red-bean.com/nightly/en/svn.branchmerge.advanced.html#svn.branchmerge.advanced.finalword">
        复杂和满是小毛病</ulink>。</para>

    <para id="x_a9">我测试了两者的性能，Mercurial在所有操作上都有了实质性的
      提高。当与使用了Subversion中最快访问方式<emphasis>ra_local</emphasis>
      文件存储方式的1.4.3版本进行对比时，它都快了2到6个数量级。在大多
      数实际使用的网络环境中，Subversion更是显示出了更大的劣势。因为很多
      Subversion的命令都必须与服务器进行通讯，而且Subversion缺少有效的拷贝机
      制，这使得在稍微大型点儿的项目中，服务器的处理能力和网络带宽就成了一个
      瓶颈。</para>

    <para id="x_aa">另外，Subversion为了使得一些命令可以离线完成，比如查找已
      修改的文件(<literal>status</literal>)和显示相对于最新版本的改动(<literal>
      diff</literal>时，使用了相当大的存储开销。这导致了一个Subversion的工作
      复本经常等于或者大于同样的Mercurial仓库加上工作目录，而Mercurial可是包
      含了项目的完整历史的。</para>

    <para id="x_ab">Subversion有着广泛的第三方工具支持。而Mercurial目前为止
      还步履蹒跚。不过，这个缺口正在填补中，目前已经有一些Mercurial的GUI工具
      确实做得已经比Subversion同样的工具更出色了。和Mercurial一样，Subversion
      也有着非常出色的用户手册。</para>

    <para id="x_ac">因为Subversion不支持在客户端保存版本历史，它非常适合管理
      那些拥有大量巨大的，不透明的二进制文件的项目。如果你对一个未压缩的10M
      文件保存了50个版本，那么Subversion的客户端空间占用量是恒定的，而任何分
      布式SCM都会快速成比例的增加使用量，因为每个文件的变更都是非常巨大的。
    </para>

    <para
      id="x_ad">通常合并一个二进制文件的不同版本是极其困难的，甚至更多情况是
      不可能的。Subversion可以让用户锁定一个文件，这样他们可以临时排他的进行
      这个文件变更的提交，这可以说对于一个广泛使用了二进制文件项目的巨大优势。</para>

    <para id="x_ae">Mercurial可以导入Subversion的仓库历史记录。它同样可以导出
      版本历史到一个Subversion仓库。这使得在正式决定使用Mercurial前的<quote>
      试水</quote>和并行使用Mercurial和Subversion都变得非常方便。历史的转换是
      递增的，所以当完成了首次转换后，以后每次转换都只转换之后的新变更。</para>


  </sect2>
  <sect2>
    <title>Git</title>

    <para id="x_af">Git是一个为了管理Linux内核代码树而开发的分布式版本控制工
      具。和Mercurial一样，它早期的设计也多少受到了Monotone的影响。 </para>

    <para id="x_b0">Git有非常巨大的命令集，1.5.0版时有139个独立的命令。它的
      学习难度已经名扬四海了。相比Git，Mercurial非常注重于简易性。 </para>

    <para id="x_b1">在性能方面，Git是极快的。在一些场合，起码是在Linux上，它
      比Mercurial更快，不过在其他操作上，Mercurial则比Git更快。但是，在Windows
      平台上，在本书写作时，Git还是远远比Mercurial慢。 </para>

    <para
      id="x_b2">Git仓库需要对它的元数据进行频繁的手工<quote>重新打包</quote>，
      否则随着空间使用量的快速增长，性能会大打折扣，而Mercurial仓库则完全是
      免维护的。一个包含着大量Git仓库的服务器如果不进行严厉且频繁的重新打包，
      会在备份时对磁盘造成严重的负担，直至它们最后要花费超过24小时的时间来
      完成一次每日备份。而一个刚刚打包过的仓库则会稍微比Mercurial仓库小一些，
      不过一个解了包的仓库可比Mercurial仓库大了好几个数量级啊。</para>

    <para id="x_b3">Git的核心是C写的。很多Git命令是用Shell或者Perl脚本实现的，
      它们的品质参差不齐。我曾经遇到过一些深藏不露的错误，可能会导致致命错误。
      </para>

    <para id="x_b4">Mercurial可以导入Git仓库的版本历史。</para>


  </sect2>
  <sect2>
    <title>CVS</title>

    <para id="x_b5">CVS可能是目前世界上使用最广泛的版本控制工具（译者注：
      本人强烈感觉这是5年前的样子，现在应该是SVN了，至少也是SourceSafe吧）。
      由于时代久远加上内部的混乱性，它已经好多年只做做简单的维护了。</para>

    <para id="x_b6">它采用了客户端/服务端架构。它不会讲相关文件归组后进行原
      子提交，这导致了人们一不小心就会让整个编译构建失败：当一个人成功的提交
      了一部分变更，然后另外一部分需要合并后才能再提交，那么其他人会只看到提
      交了未完成的部分提交。这也会影响你对项目历史的工作方式。如果你想看看所
      有某人对某项工作所做的所有修改，你必须手工调查每个相关文件的描述和时间
      戳（如果你知道是哪些文件的话）。</para>

    <para id="x_b7">CVS还有一个混乱到我都不想提起的标签和分支的标注方式。它
      不能很好的支持对文件和文件夹的重命名，这会导致一不小心就会破坏整个仓库。
      它几乎不能对内部的一致性进行检查，所以它甚至都不知道自己是否已经被破坏
      了，以及怎么被破坏了的。我不会再向任何项目推荐使用CVS，无论是新是旧。</para>

    <para id="x_b8">Mercurial可以导入CVS的版本历史。但是，在此之前你必须清楚
      了解以下不足，这些不足同样存在于其他可以导入CVS版本历史的的版本控制工
      具。因为CVS缺乏原子变更支持和不对文件系统进行版本控制，所以无法精确重建
      CVS的历史。构建过程中会有一些猜测，而且重命名有时不会被显现出来。因为很
      多高级的CVS管理工作必须手工完成，（完全伪造的版本时间戳和十来个被锁定的
      文件是我从个人经验中还能回忆起来的不怎么有趣的问题）这多少会造成一些错
      误，所以当导入CVS时发生一堆错误甚至破坏整个仓库也是很普遍的现象。</para>

    <para id="x_b9">Mercurial可以从CVS仓库中导入版本历史。</para>


  </sect2>
  <sect2>
    <title>商业工具</title>

    <para id="x_ba">Perforce采用了中心化客户端/服务端架构，客户端不缓存任何数
      据。与现代版本控制工具不同，在编辑本地文件前需要执行一个命令通知Perforce。
    </para>

    <para id="x_bb">对于小团队来说，Perforce的性能相当不错，但是一旦用户数开
      始增长到几十人时，它的性能就一落千丈了。稍大点儿的Perforce安装需要部
      署代理服务器以应对用户产生的负荷。</para>


  </sect2>
  <sect2>
    <title>选择一个版本控制工具</title>

    <para id="x_bc">
      除了CVS以外，上述所有工具都有各自独特的优势，使其适合特定类型的工作。没
      有一个版本控制工具对于所有情况都是最佳的。 </para>

    <para id="x_bd">比如说，Subversion的集中性和对文件锁定的支持，特别适合需
      要频繁编辑二进制文件的场合。</para>

    <para id="x_be">我个人觉得，Mercurial的简单、高效以及良好的合并支持形成了
      令人难以抗拒的组合，我已经因此获益好多年了。</para>

  </sect2>
</sect1>
<sect1>
  <title>从其他工具切换到Mercurial来</title>

  <para id="x_bf">Mercurial自带了一个叫做<literal role="hg-ext">convert
    </literal>的扩展，他可以增量的将其他版本控制工具的版本历史导入进来。
    所谓<quote>增量</quote>，我是指你可以一下子把一个项目的所有历史导入进来，
    以后只需再运行一次即可导入上次转换后新增加的变更历史。</para>

  <para id="x_c0"><literal role="hg-ext">convert</literal>支持以下版本控制工
    具：</para>
  <itemizedlist>
    <listitem><para id="x_c1">Subversion</para></listitem>
    <listitem><para id="x_c2">CVS</para></listitem>
    <listitem><para id="x_c3">Git</para></listitem>
    <listitem><para id="x_c4">Darcs</para></listitem></itemizedlist>

  <para id="x_c5">另外，<literal role="hg-ext">convert</literal>同样支持从
    Mercurial导出数据到Subversion。这样就可以让人们在正式切换前，先并行的使用
    一段时间，而不需要冒着任何丢失工作数据的风险。</para>

  <para id="x_c6"><command role="hg-ext-convert">convert</command>命令非常容
    易使用。只要简单的指明源仓库的路径或者URL，然后给目标仓库起个名字（可选的），
    它就能开始导入了。在初次转换后，只要运行相同的命令，就能导入之后新的变更
    历史。</para>
</sect1>

<sect1>
  <title>版本控制简史</title>

  <para id="x_c7">SCCS(Source Code Control System)是上古时代最有名的版本控制
    工具，它是由Marc Rochkind在20世纪70年代初期在贝尔实验室写就的。SCCS对各自
    文件进行操作，而且需要每个项目工作人员都要有一个单一系统上共享空间的访问
    权限。每次只有一个人可以修改一个文件。文件是通过锁定来判断是否被人修改的。
    所以很容易出现人们在锁定了文件后忘记解锁，从来使得其他人无法修改这些文件，
    除非向管理员来寻求帮助。 </para>

  <para id="x_c8">Walter Tichy在20世纪80年代开发了一个SCCS的自由软件替代品，
    他把他的程序命名为RCS(Revision Control System)。和SCCS一样，RCS也需要开
    发者工作在单个共享的工作空间，并且依靠锁定来避免多人同时修改一个文件。
  </para>

  <para id="x_c9">到了80年代后期，Dick Grune在RCS的基础上，创建了一系列的Shell
    脚本，起初他命名为cmt，不过后来就改名为CVS（Concurrent Versions System）。
    CVS的伟大创新在于它使得开发者可以同时工作，并且每个人拥有自己的个人工作
    空间。个人工作空间可以防止开发者不小心踩到对方的脚趾上（意思为不会互相干
    扰了），而这种情况在SCCS和RCS上非常普遍。每个开发者都拥有整个项目所有文件
    的复本，所以可以独立的编辑他们自己的文件。在提交他们的变更前，他们必须和中
    央仓库进行一次合并。</para>

  <para id="x_ca">Brian Berliner把Grune的原始脚本全部修改成了C语言，并在1989
    年颁布了这个演变成现代版本CVS的源代码。CVS随后拥有了联网操作能力，使得它
    变成了客户端/服务端架构。CVS的架构还是基于中心化的，只有服务器才拥有项目
    的完整历史，而客户端的工作空间只包含了最近一次的项目版本，加上一些告诉它
    服务器在哪儿的元数据。CVS获得了巨大的成功，它几乎成了世界上使用最广泛的版
    本控制软件。</para>

  <para id="x_cb">到了90年代初期，Sun Microsystems开发了一个早期的分布式版本
    控制系统，叫做TeamWare。一个TeamWare工作空间包含了这个项目的完整历史。
    TeamWare没有标注任何中央服务器。（CVS使用RCS作为它的历史存储方式，而TeamWare
    采用了SCCS。）</para>

  <para id="x_cc">在整个90年代，CVS的问题逐步显现出来。它各自记录了一次修改的
    多个文件，而不是把它们打包成一个组来进行单次逻辑上的原子操作。它也不能很
    好的管理文件层次，所以对文件和目录的重命名很容易造成仓库的混乱。更要命的
    是，它的源代码难以阅读和维护，这使得修改修改这些架构上的问题的难度极度上
    升。</para>

  <para id="x_cd">到了2001年，Jim Blandy和Karl Fogel，两个工作在CVS上的开发者，
    开始了一项旨在替换CVS的项目，该项目拥有更好的架构和更清晰的代码。结果就是
    Subversion，一个更好的但是还是中心化的客户端/服务端模式的版本控制工具。不
    过，它追加了多文件原子提交，更好的命名空间管理和一些其他的特性，这使得它
    比CVS好上很多。从初次发布开始，它已经得到了飞速广泛的应用。</para>

  <para id="x_ce">在差不多同一时候，Graydon Hoare开始了他雄心勃勃的分布式版本
    控制系统，他叫它Monotone。Monotone就是冲着那些CVS的设计缺陷去的，并且拥有
    点对点的架构，这让它比之前（以及随后一些）的版本控制工具在很多方面上都具
    创新性。它使用一个加密的哈希值作为标示，对于来自不同源头的代码，它有内置的所谓
    <quote>信赖</quote>的概念。</para>

  <para id="x_cf">Mercurial诞生于2005年，它的一些设计深受Monotone的影响，
    Mercurial专注于易用性，高性能和对极大规模项目的可扩展性。</para>
</sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
